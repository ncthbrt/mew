use std::str::FromStr;
use crate::{error::ParseError, lexer::Token};
use crate::syntax::*;
use crate::parser_support::*;

// this grammar follows closely the wgsl spec.
// follwing the spec at this date: https://www.w3.org/TR/2024/WD-WGSL-20240731/

grammar;

extern {
    type Location = usize;
    type Error = (usize, ParseError, usize);
    enum Token {
        // syntactic tokens
        // https://www.w3.org/TR/WGSL/#syntactic-tokens

        // BEGIN WESL ADDITIONS
        ".." => Token::SymDoublePeriod,
        "::" => Token::SymDoubleColon,
        // END WESL ADDITIONS
        "&" => Token::SymAnd,
        "&&" => Token::SymAndAnd,
        "->" => Token::SymArrow,
        "@" => Token::SymAttr,
        "/" => Token::SymForwardSlash,
        "!" => Token::SymBang,
        "[" => Token::SymBracketLeft,
        "]" => Token::SymBracketRight,
        "{" => Token::SymBraceLeft,
        "}" => Token::SymBraceRight,
        ":" => Token::SymColon,
        "," => Token::SymComma,
        "=" => Token::SymEqual,
        "==" => Token::SymEqualEqual,
        "!=" => Token::SymNotEqual,
        ">" => Token::SymGreaterThan,
        ">=" => Token::SymGreaterThanEqual,
        ">>" => Token::SymShiftRight,
        "<" => Token::SymLessThan,
        "<=" => Token::SymLessThanEqual,
        "<<" => Token::SymShiftLeft,
        "%" => Token::SymModulo,
        "-" => Token::SymMinus,
        "--" => Token::SymMinusMinus,
        "." => Token::SymPeriod,
        "+" => Token::SymPlus,
        "++" => Token::SymPlusPlus,
        "|" => Token::SymOr,
        "||" => Token::SymOrOr,
        "(" => Token::SymParenLeft,
        ")" => Token::SymParenRight,
        ";" => Token::SymSemicolon,
        "*" => Token::SymStar,
        "~" => Token::SymTilde,
        "_" => Token::SymUnderscore,
        "^" => Token::SymXor,
        "+=" => Token::SymPlusEqual,
        "-=" => Token::SymMinusEqual,
        "*=" => Token::SymTimesEqual,
        "/=" => Token::SymDivisionEqual,
        "%=" => Token::SymModuloEqual,
        "&=" => Token::SymAndEqual,
        "|=" => Token::SymOrEqual,
        "^=" => Token::SymXorEqual,
        ">>=" => Token::SymShiftRightAssign,
        "<<=" => Token::SymShiftLeftAssign,

        // keywords
        // https://www.w3.org/TR/WGSL/#keyword-summary
        "alias" => Token::KwAlias,
        "break" => Token::KwBreak,
        "case" => Token::KwCase,
        "const" => Token::KwConst,
        "const_assert" => Token::KwConstAssert,
        "continue" => Token::KwContinue,
        "continuing" => Token::KwContinuing,
        "default" => Token::KwDefault,
        "diagnostic" => Token::KwDiagnostic,
        "discard" => Token::KwDiscard,
        "else" => Token::KwElse,
        "enable" => Token::KwEnable,
        "false" => Token::KwFalse,
        "fn" => Token::KwFn,
        "for" => Token::KwFor,
        "if" => Token::KwIf,
        "let" => Token::KwLet,
        "loop" => Token::KwLoop,
        "override" => Token::KwOverride,
        "requires" => Token::KwRequires,
        "return" => Token::KwReturn,
        "struct" => Token::KwStruct,
        "switch" => Token::KwSwitch,
        "true" => Token::KwTrue,
        "var" => Token::KwVar,
        "while" => Token::KwWhile,
        // BEGIN WESL ADDITIONS
        "use" => Token::KwUse,
        "mod" => Token::KwMod,        
        "include" => Token::KwInclude,
        "sig" => Token::KwSig,
        // END WESL ADDITIONS
        IdentPatternToken => Token::Ident(<String>),
        TokAbstractInt => Token::AbstractInt(<i64>),
        TokAbstractFloat => Token::AbstractFloat(<f64>),
        TokI32 => Token::I32(<i32>),
        TokU32 => Token::U32(<u32>),
        TokF32 => Token::F32(<f32>),
        TokF16 => Token::F16(<f32>),
        TokTemplateArgsStart => Token::TemplateArgsStart,
        TokTemplateArgsEnd => Token::TemplateArgsEnd,
    }
}

// the grammar rules are layed out in the same order as in the spec.
// follwing the spec at this date: https://www.w3.org/TR/2024/WD-WGSL-20240731/

// custom entrypoint called by the lexer when it sees [Token::Ident, Token::SymLessThan].
// if this parse succeeds, the next token emitted by the lexer will be TokTemplateList.
// pub TryTemplateList: Span = {
//    <l:@L> TokTemplateArgsStart TemplateArgCommaList TokTemplateArgsEnd <r:@R> => { (l..r) },
//};

// =====================
// === Begin grammar ===
// =====================

// 2. WGSL MODULE
// https://www.w3.org/TR/WGSL/#wgsl-module

pub TranslationUnit: TranslationUnit = {
    <global_directives: GlobalDirective*> <global_declarations: GlobalDecl*> => TranslationUnit {<>},
};

GlobalDecl: GlobalDeclaration = {
    ";"                        => GlobalDeclaration::Void,
    <GlobalVariableDecl> ";"   => GlobalDeclaration::Declaration(<>),
    <GlobalValueDecl> ";"      => GlobalDeclaration::Declaration(<>),
    <AliasDecl> ";"        => GlobalDeclaration::Alias(<>),
    <StructDecl>               => GlobalDeclaration::Struct(<>),
    <FunctionDecl>             => GlobalDeclaration::Function(<>),
    <ConstAssertStatement> ";" => GlobalDeclaration::ConstAssert(<>),
    // BEGIN WESL global decls
    <ModuleDecl> => GlobalDeclaration::Module(<>),
    // END WESL global decls
};

// BEGIN WESL ROOT ADDITIONS
ModuleDecl : Module = {
    <attributes: Attribute*> "mod" <name: Ident>  "{" <members: ModuleMemberDecl*> "}"  => Module {
        name, 
        members,
        attributes,
    }
};

ModuleMemberDecl: ModuleMemberDeclaration = {
    ";"                        => ModuleMemberDeclaration::Void,
    <GlobalVariableDecl> ";"   => ModuleMemberDeclaration::Declaration(<>),
    <ModuleValueDecl> ";"      => ModuleMemberDeclaration::Declaration(<>),
    <AliasDecl> ";"        => ModuleMemberDeclaration::Alias(<>),
    <StructDecl>               => ModuleMemberDeclaration::Struct(<>),
    <FunctionDecl>             => ModuleMemberDeclaration::Function(<>),
    <ConstAssertStatement> ";" => ModuleMemberDeclaration::ConstAssert(<>),
    <ModuleDecl> => ModuleMemberDeclaration::Module(<>),
};

// END WESL ROOT ADDITIONS

DiagnosticRuleName: String = {
    DiagnosticNameToken,
    <first: DiagnosticNameToken> "." <last: DiagnosticNameToken> => format!("{first}.{last}"),
};

// 3. TEXTUAL STRUCTURE
// https://www.w3.org/TR/WGSL/textual-structure#

// XXX: non-conformant
// https://www.w3.org/TR/WGSL/#syntax-literal
Literal: LiteralExpression = {
    TokAbstractInt   => LiteralExpression::AbstractInt(<>),
    TokAbstractFloat => LiteralExpression::AbstractFloat(<>),
    TokI32           => LiteralExpression::I32(<>),
    TokU32           => LiteralExpression::U32(<>),
    TokF32           => LiteralExpression::F32(<>),
    TokF16           => LiteralExpression::F16(<>),
    BoolLiteral,
};

BoolLiteral: LiteralExpression = {
    "true"  => LiteralExpression::True,
    "false" => LiteralExpression::False,
};

Ident: String = {
    IdentPatternToken /* _DisambiguateTemplate */ => <>,
};

MemberIdent: String = {
    IdentPatternToken => <>,
};

// TODO: check context-dependent names below.

BuiltinValueName: String = {
    IdentPatternToken => <>,
};

DiagnosticNameToken: String = {
    IdentPatternToken => <>,
};

SeverityControlName: DiagnosticSeverity = {
    <l: @L> <ident: IdentPatternToken> <r: @R> =>? {
        DiagnosticSeverity::from_str(&ident).map_err(|e| lalrpop_util::ParseError::User{ error: (l, e, r) })
    },
};

EnableExtensionName: String = {
    IdentPatternToken => <>,
};

SoftwareExtensionName: String = {
    IdentPatternToken => <>,
};

InterpolateSamplingName: String = {
    IdentPatternToken => <>,
};

SwizzleName: String = {
    IdentPatternToken => <>,
};

TemplateList: Vec<TemplateArg> = {
    TokTemplateArgsStart <TemplateArgCommaList> TokTemplateArgsEnd,
};

TemplateArgCommaList: Vec<TemplateArg> = {
    Comma1<TemplateArgExpression>,
};

TemplateArgExpression: Expression = {
    Expression,
};

// 4. DIRECTIVES
// https://www.w3.org/TR/WGSL/#directives
GlobalDirective: GlobalDirective = {
    DiagnosticDirective => GlobalDirective::Diagnostic(<>),
    EnableDirective     => GlobalDirective::Enable(<>),
    RequiresDirective   => GlobalDirective::Requires(<>),
};

EnableDirective: EnableDirective = {
    "enable" <extensions: EnableExtensionList> ";" => EnableDirective {
        extensions
    },
};

EnableExtensionList: Vec<String> = {
    Comma1<EnableExtensionName>,
};

RequiresDirective: RequiresDirective = {
    "requires" <extensions: SoftwareExtensionList> ";" => RequiresDirective {
        extensions
    },
};

SoftwareExtensionList: Vec<String> = {
    Comma1<SoftwareExtensionName>,
};

DiagnosticDirective: DiagnosticDirective = {
    "diagnostic" <DiagnosticControl> ";" => {
        let (severity, rule_name) = <>;
        DiagnosticDirective { severity, rule_name }
    },
};

// 5. DECLARATION AND SCOPE
// https://www.w3.org/TR/WGSL/#declaration-and-scope

// 6. TYPES
// https://www.w3.org/TR/WGSL/#types

StructDecl: Struct = {
    "struct" <name: Ident> <members: StructBodyDecl> => Struct {
        name, members
    },
};

StructBodyDecl: Vec<StructMember> = {
    "{" <Comma1<StructMember>> "}",
};

StructMember: StructMember = {
    <attributes: Attribute*> <name: MemberIdent> ":" <typ: TypeSpecifier> => StructMember {
        attributes, name, typ
    },
};

AliasDecl: Alias = {
    "alias" <name: Ident> "=" <typ: TypeSpecifier> => Alias {
        name, typ
    },
};

TypeSpecifier: TypeExpression = {
    TemplateElaboratedIdent => {
        let TemplateElaboratedIdent { path, template_args } = <>;
        TypeExpression { path, template_args }
    },
};

TemplateElaboratedIdent: TemplateElaboratedIdent = {
    <mut path: (<Ident> "::")*> <last: Ident> /* DisambiguateTemplate */ <template_args: TemplateList?> => {
        path.push(last);
        TemplateElaboratedIdent {
            path,
            template_args
        }
    },
};

// 7. VARIABLE AND VALUE DECLARATIONS
// https://www.w3.org/TR/WGSL/#var-and-value

VariableOrValueStatement: Declaration = {
    VariableDecl,
    <mut decl: VariableDecl> "=" <initializer: Expression> => {
        decl.initializer = Some(initializer);
        decl
    },
    "let" <ident: OptionallyTypedIdent> "=" <initializer: Expression> => {
        let (name, typ) = ident;
        Declaration {
            attributes: Vec::new(),
            kind: DeclarationKind::Let,
            template_args: None,
            name,
            typ,
            initializer: Some(initializer),
        }
    },
    "const" <ident: OptionallyTypedIdent> "=" <initializer: Expression> => {
        let (name, typ) = ident;
        Declaration {
            attributes: Vec::new(),
            kind: DeclarationKind::Let,
            template_args: None,
            name,
            typ,
            initializer: Some(initializer),
        }
    },
};

VariableDecl: Declaration = {
    "var" /* DisambiguateTemplate */ <template_args: TemplateList?> <ident: OptionallyTypedIdent> => {
        let (name, typ) = ident;
        Declaration {
            attributes: Vec::new(),
            kind: DeclarationKind::Var,
            template_args,
            name,
            typ,
            initializer: None,
        }
    },
};

OptionallyTypedIdent: (String, Option<TypeExpression>) = {
    <Ident> <(":" <TypeSpecifier>)?>,
};

GlobalVariableDecl: Declaration = {
    <attributes: Attribute*> <mut decl: VariableDecl> <initializer: ("=" <Expression>)?> => {
        decl.attributes = attributes;
        decl.initializer = initializer.map(Into::into);
        decl
    },
};

// BEGIN WESL MODIFICATIONS
ModuleValueDecl: Declaration = {
    "const" <ident: OptionallyTypedIdent> "=" <initializer: Expression> => {
        let (name, typ) = ident;
        return Declaration {
            attributes: Vec::new(),
            kind: DeclarationKind::Const,
            template_args: None,
            name,
            typ,
            initializer: Some(initializer)
        }
    },
};

GlobalValueDecl: Declaration = {
    "const" <ident: OptionallyTypedIdent> "=" <initializer: Expression> => {
        let (name, typ) = ident;
        return Declaration {
            attributes: Vec::new(),
            kind: DeclarationKind::Const,
            template_args: None,
            name,
            typ,
            initializer: Some(initializer),
        }
    },
    <attributes: Attribute*> "override" <ident: OptionallyTypedIdent> <initializer: ("=" <Expression>)?> => {
        let (name, typ) = ident;
        Declaration {
            attributes,
            kind: DeclarationKind::Override,
            template_args: None,
            name,
            typ,
            initializer: initializer.map(Into::into),
        }
    }
};
// END WESL MODIFICATIONS

// 8. EXPRESSIONS
// https://www.w3.org/TR/WGSL/#expressions

// BEGIN WESL MODIFICATIONS

PrimaryExpression: Expression = {
    TemplateElaboratedIdent => {
        let  TemplateElaboratedIdent { path, template_args } = <>;
        match template_args {
            Some(_) => Expression::Type(TypeExpression { path, template_args }),
            None => Expression::Identifier(IdentifierExpression {
                path
            }),
        }
    }, // XXX: not sure about this one, is it type?
    CallExpression,
    Literal => Expression::Literal(<>),
    ParenExpression,
};
// END WESL MODIFICATIONS


CallExpression: Expression = {
    CallPhrase => Expression::FunctionCall(<>),
};

CallPhrase: FunctionCallExpression = {
    <callee: TemplateElaboratedIdent> <arguments: ArgumentExpressionList> => {
        let TemplateElaboratedIdent { path, template_args } = callee;
        FunctionCallExpression {
            path, template_args, arguments
        }
    },
};

ParenExpression: Expression = {
    "(" <Expression> ")" => Expression::Parenthesized(<>.into()),
};

ArgumentExpressionList: Vec<Expression> = {
    "(" <ExpressionCommaList?> ")" => <>.unwrap_or_default(),
};

ExpressionCommaList: Vec<Expression> = {
    Comma1<Expression>,
};

// was modified from the spec, but should be equivalent
ComponentOrSwizzleSpecifier: Vec<Component> = {
    // "[" Expression "]" ComponentOrSwizzleSpecifier?,
    // "." MemberIdent ComponentOrSwizzleSpecifier?,
    // "." SwizzleName ComponentOrSwizzleSpecifier ?,
    SingleComponentOrSwizzleSpecifier+
};

SingleComponentOrSwizzleSpecifier: Component = {
    "[" <Expression> "]" => Component::Index(<>.into()),
    "." <MemberIdent>       => Component::Named(<>),
}

UnaryExpression: Expression = {
    SingularExpression,
    "-" <operand: UnaryExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::Negation, operand: operand.into()
    }),
    "!" <operand: UnaryExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::LogicalNegation, operand: operand.into()
    }),
    "~" <operand: UnaryExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::BitwiseComplement, operand: operand.into()
    }),
    "*" <operand: UnaryExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::Indirection, operand: operand.into()
    }),
    "&" <operand: UnaryExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::AddressOf, operand: operand.into()
    }),
};

SingularExpression: Expression = {
    <expr: PrimaryExpression> <components: ComponentOrSwizzleSpecifier?> => match components {
        Some(components) => apply_components(components, expr),
        None => expr
    },
};

LhsExpression: Expression = {
    <expr: CoreLhsExpression> <components: ComponentOrSwizzleSpecifier?> => match components {
        Some(components) => apply_components(components, expr),
        None => expr
    },
    "*" <operand: LhsExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::Indirection, operand: operand.into()
    }),
    "&" <operand: LhsExpression> => Expression::Unary(UnaryExpression {
        operator: UnaryOperator::AddressOf, operand: operand.into()
    }),
 };
 
CoreLhsExpression: Expression = {
    Ident /* DisambiguateTemplate */ => Expression::Identifier(IdentifierExpression { path: vec![<>] }),
    "(" <LhsExpression> ")" => Expression::Parenthesized(<>.into()),
};

MultiplicativeExpression: Expression = {
    UnaryExpression,
    <left: MultiplicativeExpression> <operator: MultiplicativeOperator> <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator, left: left.into(), right: right.into()
    }),
};

MultiplicativeOperator: BinaryOperator = {
    "*" => BinaryOperator::Multiplication,
    "/" => BinaryOperator::Division,
    "%" => BinaryOperator::Remainder,
};
 
AdditiveExpression: Expression = {
    MultiplicativeExpression,
    <left: AdditiveExpression> <operator: AdditiveOperator> <right: MultiplicativeExpression> => Expression::Binary(BinaryExpression {
        operator, left: left.into(), right: right.into()
    }),
};

AdditiveOperator: BinaryOperator = {
    "+" => BinaryOperator::Addition,
    "-" => BinaryOperator::Subtraction,
};

ShiftExpression: Expression = {
    AdditiveExpression,
    <left: UnaryExpression> "<<" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::ShiftLeft, left: left.into(), right: right.into()
    }),
    <left: UnaryExpression> ">>" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::ShiftRight, left: left.into(), right: right.into()
    }),
};

RelationalExpression: Expression = {
    ShiftExpression,
    <left: ShiftExpression> "<" <right: ShiftExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::LessThan, left: left.into(), right: right.into()
    }),
    <left: ShiftExpression> ">" <right: ShiftExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::GreaterThan, left: left.into(), right: right.into()
    }),
    <left: ShiftExpression> "<=" <right: ShiftExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::LessThanEqual, left: left.into(), right: right.into()
    }),
    <left: ShiftExpression> ">=" <right: ShiftExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::GreaterThanEqual, left: left.into(), right: right.into()
    }),
    <left: ShiftExpression> "==" <right: ShiftExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::Equality, left: left.into(), right: right.into()
    }),
    <left: ShiftExpression> "!=" <right: ShiftExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::Inequality, left: left.into(), right: right.into()
    }),
};

ShortCircuitAndExpression: Expression = {
    RelationalExpression,
    <left: ShortCircuitAndExpression> "&&" <right: RelationalExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::ShortCircuitAnd, left: left.into(), right: right.into()
    }),
 };
 
ShortCircuitOrExpression: Expression = {
    RelationalExpression,
    <left: ShortCircuitOrExpression> "||" <right: RelationalExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::ShortCircuitOr, left: left.into(), right: right.into()
    }),
 };
 
BinaryOrExpression: Expression = {
    UnaryExpression,
    <left: BinaryOrExpression> "|" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::BitwiseOr, left: left.into(), right: right.into()
    }),
};

BinaryAndExpression: Expression = {
    UnaryExpression,
    <left: BinaryAndExpression> "&" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::BitwiseAnd, left: left.into(), right: right.into()
    }),
};

BinaryXorExpression: Expression = {
    UnaryExpression,
    <left: BinaryXorExpression> "^" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::BitwiseXor, left: left.into(), right: right.into()
    }),
};

BitwiseExpression: Expression = {
    <left: BinaryAndExpression> "&" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::BitwiseAnd, left: left.into(), right: right.into()
    }),
    <left: BinaryOrExpression> "|" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::BitwiseOr, left: left.into(), right: right.into()
    }),
    <left: BinaryXorExpression> "^" <right: UnaryExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::BitwiseXor, left: left.into(), right: right.into()
    }),
};

Expression: Expression = {
    RelationalExpression,
    <left: ShortCircuitOrExpression> "||" <right: RelationalExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::ShortCircuitOr, left: left.into(), right: right.into()
    }),
    <left: ShortCircuitAndExpression> "&&" <right: RelationalExpression> => Expression::Binary(BinaryExpression {
        operator: BinaryOperator::ShortCircuitAnd, left: left.into(), right: right.into()
    }),
    BitwiseExpression,
};

// 9. STATEMENTS
// https://www.w3.org/TR/WGSL/#statements

CompoundStatement: CompoundStatement = {
    <attributes: Attribute*> "{" <statements: Statement*> "}" => {
        let mut statement = CompoundStatement {
            attributes, statements
        };
        statement.construct_scope_tree();
        statement
    },
};

AssignmentStatement: AssignmentStatement = {
    <lhs: LhsExpression> "=" <rhs: Expression> => AssignmentStatement {
        operator: AssignmentOperator::Equal, lhs, rhs
    },
    <lhs: LhsExpression> <operator: CompoundAssignmentOperator> <rhs: Expression> => AssignmentStatement {
        operator, lhs, rhs
    },
    "_" "=" <rhs: Expression> => {
        let lhs = Expression::Identifier(IdentifierExpression { path: vec!["_".to_string()] });
        AssignmentStatement { operator: AssignmentOperator::Equal, lhs, rhs }
    },
};

CompoundAssignmentOperator: AssignmentOperator = {
    "+=" => AssignmentOperator::PlusEqual,
    "-=" => AssignmentOperator::MinusEqual,
    "*=" => AssignmentOperator::TimesEqual,
    "/=" => AssignmentOperator::DivisionEqual,
    "%=" => AssignmentOperator::ModuloEqual,
    "&=" => AssignmentOperator::AndEqual,
    "|=" => AssignmentOperator::OrEqual,
    "^=" => AssignmentOperator::XorEqual,
    ">>=" => AssignmentOperator::ShiftRightAssign,
    "<<=" => AssignmentOperator::ShiftLeftAssign,
};

IncrementStatement: Expression = {
    <LhsExpression> "++",
};

DecrementStatement: Expression = {
    <LhsExpression> "--",
};

IfStatement: IfStatement = {
    <attributes: Attribute*> <if_clause: IfClause> <else_if_clauses: ElseIfClause*> <else_clause: ElseClause?> => IfStatement {
        attributes, if_clause, else_if_clauses, else_clause
    },
};

IfClause = "if" <Expression> <CompoundStatement>;

ElseIfClause = "else" "if" <Expression> <CompoundStatement>;

ElseClause = "else" <CompoundStatement>;

SwitchStatement: SwitchStatement = {
    <attributes: Attribute*> "switch" <expression: Expression> <body: SwitchBody> => {
        let (body_attributes, clauses) = body;
        SwitchStatement {
            attributes, expression, body_attributes, clauses
        }
    },
};

SwitchBody: (Vec<Attribute>, Vec<SwitchClause>) = {
    <Attribute*> "{" <SwitchClause+> "}",
};

SwitchClause: SwitchClause = {
    CaseClause,
    DefaultAloneClause,
};

CaseClause: SwitchClause = {
    "case" <case_selectors: CaseSelectors> ":"? <body: CompoundStatement> => SwitchClause {
        case_selectors, body
    },
};

DefaultAloneClause: SwitchClause = {
    "default" ":"? <body: CompoundStatement> => SwitchClause {
        case_selectors: vec![CaseSelector::Default], body
    },
};

CaseSelectors: Vec<CaseSelector> = {
    Comma1<CaseSelector>,
};

CaseSelector: CaseSelector = {
    "default" => CaseSelector::Default,
    Expression => CaseSelector::Expression(<>),
};

LoopStatement: LoopStatement = {
    <attributes: Attribute*> "loop" <body_attributes: Attribute*> "{" <statements: Statement*> <continuing: ContinuingStatement?> "}" => {
        let body = CompoundStatement { attributes: body_attributes, statements };
        LoopStatement {
            attributes, body, continuing
        }
    },
};

ForStatement: ForStatement = {
     <attributes: Attribute*> "for" "(" <header: ForHeader> ")" <body: CompoundStatement> => {
        let (initializer, condition, update) = header;
        ForStatement {
            attributes, initializer: initializer.map(Into::into), condition, update: update.map(Into::into), body
        }
    },
};

ForHeader: (Option<Statement>, Option<Expression>, Option<Statement>) = {
    <ForInit?> ";" <Expression?> ";" <ForUpdate?>,
};

ForInit: Statement = {
    VariableOrValueStatement  => Statement::Declaration(DeclarationStatement { declaration: <>, statements: vec![] }),
    VariableUpdatingStatement => <>,
    FuncCallStatement         => Statement::FunctionCall(<>),
};

ForUpdate: Statement = {
    VariableUpdatingStatement => <>,
    FuncCallStatement         => Statement::FunctionCall(<>),
};

WhileStatement: WhileStatement = {
    <attributes: Attribute*> "while" <condition: Expression> <body: CompoundStatement> => WhileStatement {
        attributes, condition, body
    },
};

BreakStatement: () = {
    "break",
};

BreakIfStatement: Expression = {
    "break" "if" <Expression> ";",
};

ContinueStatement: () = {
    "continue",
};

ContinuingStatement = "continuing" <ContinuingCompoundStatement>;

ContinuingCompoundStatement: ContinuingStatement = {
    <attributes: Attribute*> "{" <statements: Statement*> <break_if: BreakIfStatement?> "}" => {
        let body = CompoundStatement { attributes, statements };
        ContinuingStatement { body, break_if }
    },
};

ReturnStatement: Option<Expression> = {
    "return" <Expression?>,
};

FuncCallStatement = CallPhrase;

ConstAssertStatement: ConstAssert = {
    "const_assert" <Expression> => ConstAssert { expression: <> },
};

Statement: Statement = {
    ";" => Statement::Void,
    <ReturnStatement> ";" => Statement::Return(<>),
    <IfStatement> => Statement::If(<>),
    <SwitchStatement> => Statement::Switch(<>),
    <LoopStatement> => Statement::Loop(<>),
    <ForStatement> => Statement::For(<>),
    <WhileStatement> => Statement::While(<>),
    <FuncCallStatement> ";" => Statement::FunctionCall(<>),
    BreakStatement ";" => Statement::Break,
    ContinueStatement ";" => Statement::Continue,
    "discard" ";" => Statement::Discard,
    <VariableUpdatingStatement> ";" => <>,
    <CompoundStatement> => Statement::Compound(<>),
    <ConstAssertStatement> ";" => Statement::ConstAssert(<>),
    <declaration: VariableOrValueStatement> ";" => Statement::Declaration(DeclarationStatement { declaration, statements: vec![] })
};

VariableUpdatingStatement: Statement = {
    AssignmentStatement => Statement::Assignment(<>),
    IncrementStatement => Statement::Increment(<>),
    DecrementStatement => Statement::Decrement(<>),
};

// 10. FUNCTIONS
// https://www.w3.org/TR/WGSL/#functions

FunctionDecl: Function = {
    <attributes: Attribute*> <header: FunctionHeader> <body: CompoundStatement> => {
        let (name, parameters, return_attributes, return_type) = header;
        Function { attributes, name, parameters, return_attributes, return_type, body }
    },
};

FunctionHeader: (String, Vec<FormalParameter>, Vec<Attribute>, Option<TypeExpression>) = {
    "fn" <name: Ident> "(" <parameters: ParamList?> ")" <ret: ("->" <Attribute*> <TemplateElaboratedIdent>)?> => {
        let (return_attributes, return_type) = ret.map(|(return_attributes, TemplateElaboratedIdent {path , template_args})| {
            let return_type = TypeExpression { path, template_args };
            (return_attributes, Some(return_type))
        }).unwrap_or_default();
        let parameters = parameters.unwrap_or_default();
        (name, parameters, return_attributes, return_type)
    },
};

ParamList: Vec<FormalParameter> = {
    Comma1<Param>,
};

Param: FormalParameter = {
    <attributes: Attribute*> <name: Ident> ":" <typ: TypeSpecifier> => FormalParameter {
        attributes, name, typ
    },
};

// 11. ATTRIBUTES
// https://www.w3.org/TR/WGSL/#attributes

// TODO: maybe parse the well-known attributes.
Attribute: Attribute = {
    "@" <name: IdentPatternToken> <arguments: ArgumentExpressionList?> => Attribute {
        name, arguments
    }
};

DiagnosticControl: (DiagnosticSeverity, String) = {
    "(" <SeverityControlName> "," <DiagnosticRuleName> ","? ")",
};

// ===================
// === End grammar ===
// ===================

// ----------- below: macros -----------

Comma<T>: Vec<T> = {
    <mut v: (<T> ",")*> <e: T?> => match e {
        Some(e) => {
            v.push(e);
            v
        }
        None => v,
    }
};

Comma1<T>: Vec<T> = {
    <mut v: (<T> ",")*> <e: T> ","? => {
        v.push(e);
        v
    }
};

